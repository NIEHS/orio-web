# ORIO

ORIO (Online Resource for Integrative Omics) is an analysis platform for data from next generation sequencing (NGS). ORIO enables rapid analysis and integration of NGS data sets.  ORIO was designed based on three central observations:

1. Diverse biological phenomena may be represented by discrete positions in genomic space.  Think protein binding sites for transcription factor regulation or transcription start sites for transcription initiation.
2. Despite a wide diversity of NGS experiment and data types, analysis of NGS data often involves consideration and manipulation of genomic read coverage.
3. Visual inspection remains a critical component of analysis.

## Main functions

An ORIO analysis run consists of two steps.  First, the intersections between a feature list of genomic coordinates and a number of NGS data sets is performed.  Second, the NGS data sets are correlated based on these intersection values. The output of these steps may be dynamically visualized using ORIO-web.

### matrix.py

matrix.py finds the intersection of a feature list of genomic coordinates and a NGS data set.  This intersection describes the overlap of read coverage from the NGS data across genomic windows anchored on feature list positions.

```
python matrix.py [OPTIONS] BIGWIGS FEATURE_BED OUTPUT_MATRIX
```

##### Required arguments

###### BIGWIGS

matrix.py requires read coverage of a NGS data set in bigWig format. matrix.py calls bigWigAverageOverBed from the UCSC kentUtils package.  If the `--stranded_bigwgs` flag is set, two bigWig files are required.  The first bigWig file must correspond to read coverage on the 'plus' strand; the second must correspond to the 'minus' strand.  If the `--stranded_bigwigs` flag is not used, a single bigWig file is required

###### FEATURE_BED

Genomic windows are generated about entries in a standard BED file.  If the `--stranded_bed` flag is used, the BED file must have at least six columns per entry.

##### Optional arguments

###### -a, --anchor [start|end|center]

###### -b, --bin_start INTEGER (Default: -2500)

###### -n, --bin_number INTEGER (Default: 50)

###### -s, --bin_size INTEGER (Default: 100)

anchor, bin_start, bin_number, and bin_size are used to specify the genomic windows created about each genomic feature in the input BED file.  

anchor sets anchor point for each BED range at range start, end, or center, observing entry strandedness ('start' is taken as the highest value of the range for entries on the 'minus' strand).  

bin_start specifies where the genomic window starts; negative values place the starting position upstream.

bin_number specifies the number of bins used in the genomic window.  These bins are considered during generation of output matrix files.

bin_size specifies the size of each bin.  Currently, bins must be the same size.

###### --opposite_strand_fn FILENAME

If specified, read coverage values for the opposite strand of BED entries are used to generate a separate opposite-strand matrix file.  This file uses the same bins and windows as the 'same-strand' OUTPUT_MATRIX.

###### --stranded_bigwigs

If specified, strand-specific read coverage bigWigs are expected.

###### --stranded_bed

If specified, a stranded BED file is expected.  The output matrix file is then generated informed by strand.  In these stranded matrix files, more downstream positions are represented by higher positive values.

##### Output

###### OUTPUT_MATRIX

The output matrix file gives read coverage over features in the FEATURE_BED file considering coverage in the input BIGWIGS file(s). Coverage is reported in bins set by the user-defined parameters.  The first line of OUTPUT_MATRIX is a header describing the bins.  The positions given for each bin are relative to the anchor point set by `-a, --anchor`.  Each row of the matrix corresponds to an individual feature in FEATURE_BED.  Read coverage values are reported as sums in each bin.  In a strand-specific analysis, read coverage in the opposite strand may be found using `--opposite_strand_fn FILENAME`.

### matrixByMatrix.py

Considering matrix files generated by `matrix.py`, `matrixByMatrix.py` finds correlation values between NGS data sets.  `matrixByMatrix.py` clusters NGS data sets on the basis of these correlation values. Clustering is also performed on genomic features based on relative enrichment of individual NGS data sets.

```
python matrixByMatrix.py [OPTIONS] MATRIX_LIST_FN WINDOW_START BIN_NUMBER BIN_SIZE OUTPUT_JSON
```

##### Required arguments

###### MATRIX_LIST_FN

The matrix files generated by `matrix.py` to be considered by `matrixByMatrix.py` are described in  tab-delimited file `MATRIX_LIST_FN`.  Each row in the file corresponds to an individual matrix file.  In each row, the following information is given in order:  
```
MATRIX_ID    DISPLAY_NAME    FILE_PATH
```

`FILE_PATH` gives the path to the associated matrix file. `MATRIX_ID` and `DISPLAY_NAME` are principally used to annotate the `OUTPUT_JSON` for visualization in `ORIO-web`.

###### WINDOW_START

###### BIN_NUMBER

###### BIN_SIZE

`WINDOW_START`, `BIN_NUMBER`, AND `BIN_SIZE` specify the dimensions of the genomic window used in creating the read coverage matrix files.  These values should be consistent with the parameters used with `matrix.py`.

###### OUTPUT_JSON

Results of the clustering analysis are reported in `OUTPUT_JSON`.  These results are designed for visualization in `ORIO-web`.

##### Optional arguments

###### --sort_vector SORT_VECTOR_FN

If a sort vector is specified by `--sort_vector`, correlations are considering a user-defined sort vector.  The sort vector provides an individual value for each genomic feature and has the following format:

```
FEATURE_ENTRY   ENTRY_VALUE
```

When a sort vector is used, `matrixByMatrix.py` finds the pairwise correlations between the sort vector and each matrix file specified in `MATRIX_LIST_FN`.  Correlation values are found between sort vector values and read coverage sums in each bin.  These correlation values are then used to hierarchically cluster NGS data sets.

<!--
## Auxiliary functions

`ORIO` contains a number of validator functions that are implemented in `ORIO-web`.  These scripts check the formatting of input files and make sure that analysis parameters are consistent with the associated genomic assembly. -->

# ORIO-web

## Data Types

### Feature list

### Sort vector

### Data set

### Analysis

#### Analysis management

##### Create analysis

##### Modify existing analysis

#### Analysis visualization

##### Data set clustering

###### Without a sort vector

Data sets were hierarchically clustered based on Spearman rho values. Clustering results are shown as a dendrogram on the left side of the top panel. Rho values are reported by color in an *n*-by-*n* heatmap, where *n* is the number of data sets.  Rho values may also be found in tooltips when hovering over individual cells.  By clicking on a cell, a scatterplot will be generated showing the points used to derive the Spearman rho value.  A drop-down menu allows for individual values to be investigated on a bin-by-bin basis.

In the bottom panel, individual data sets may be selected in the list on the left.  Once selected, the bar plot on the right will be populated with pairwise Spearman correlation values for each other data set.  After clicking on ‘Display individual heatmap’, a window will pop up detailing the read coverage for that data set over the feature list.

In the pop up, a heatmap of read coverage over the user-specified genomic window is shown on the right. In the upper-left panel, a plot of bin-average read coverage is shown.  In the mid-left panel, a plot of bin-average read coverage over quartiles is shown.  Quartiles are generated respecting the sort order of the read coverage heatmap.  The sort order of heatmap may be changed using the lower-left panel.  By selecting a data set and clicking ‘Reorder heatmap’ the heatmap will be re-ordered to reflect read coverage of the selected data set in descending order, ie genomic features with greater read coverage in the selected data set will be on top.  The quartile plot will change upon re-ordering of the read coverage heatmap.  The p-value in the upper-left corner of the quartile plot is derived from application of the four-sample Anderson-Darling test to the quartile plots and reflects the null hypothesis that quartiles are sampled from populations that are identical.

###### With a sort vector

Data sets were hierarchically clustered.  For each data set, the read coverage sum across each bin found.  Then, for each given bin, the Spearman rho value is found between the bin read coverage sums and the sort vector.  For each data set, these correlation values are concatenated in a single data vector.  The data sets are hierarchically clustered using the pairwise Euclidean distance between each data set.  Rho values are displayed by color gradient in a *n*-by-*m* heatmap, where *n* is the number of data sets and *m* is the number of genomic bins.  By clicking on a cell, a scatterplot will be generated showing the points used to the derive the Spearman rho value.

In the bottom panel, individual data sets may be selected in the list on the left.  Once selected, the bar plot on the right will be populated with Spearman correlation values for each genomic bin.  After clicking on ‘Display individual heatmap’, a window will pop up detailing the read coverage for that data set over the feature list.

In the pop up, a heatmap of read coverage over the user-specified genomic window is shown on the right. In the upper-left panel, a plot of bin-average read coverage is shown.  In the mid-left panel, a plot of bin-average read coverage over quartiles is shown.  Quartiles are generated respecting the sort order of the read coverage heatmap.  The sort order of heatmap may be changed using the lower-left panel.  By selecting a data set and clicking ‘Reorder heatmap’ the heatmap will be re-ordered to reflect read coverage of the selected data set in descending order, i.e. genomic features with greater read coverage in the selected data set will be on top.  The quartile plot will change upon re-ordering of the read coverage heatmap.  The p-value in the upper-left corner of the quartile plot is derived from application of the four-sample Anderson-Darling test to the quartile plots and reflects the null hypothesis that quartiles are sampled from populations that are identical.

##### Feature clustering

Genomic features are clustered using *k*-means clustering. For each genomic feature, sum of the read coverage for each data set is found. These sums are then normalized such that each value is in terms of units variance. These normalized sums are concatenated into data vectors for each genomic feature. *k*-means clustering is then performed on these data vectors.  Centroids are initialized by randomly selecting individual data vectors. *k*-means clustering is iteratively performed for *k* values 2 to 10.

In the 'Feature clustering' view, clustering results are shown on the heatmap in the right panel.  Here, each row corresponds to a genomic feature, and each column corresponds to a data set. In each cell, the color represents the read coverage at a genomic feature for a data set after upper-quartile normalization.  Columns are ordered based on hierarchical clustering results with a dendrogram at the top of the panel. Bars on the left side of the panel reflect cluster membership.

In the left panel, *k* values may be selected from a drop-down list.  Members of the selected cluster are displayed in a list at the bottom of the left panel.  If selected, a genomic feature will be indicated in the heatmap by a black arrow.  Also, the values of the selected genomic feature will be displayed on the centroid chart in the bottom panel.

In the bottom panel, a two-dimensional plot displays read coverage values for cluster centroids. Values are upper-quartile normalized.  If a genomic feature is selected in the upper panel, read coverage values for that feature will be plot as a black line.
